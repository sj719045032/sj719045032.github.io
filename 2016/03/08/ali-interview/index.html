<!DOCTYPE html>
<html>
<head>
  <meta charset="utf-8">
  
  <title>2016阿里实习生第一次电话面试总结 | Stone&#39;s blog!</title>
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1">
  <meta name="description" content="2016年3月7日，晚上接到了人生中第一次电话面试-阿里实习生招聘电话面试。打来电话的是一个姐姐，下面是一些问题。
1.angular数据双向绑定的原理，以及与检测对象改变的实现双向绑定有什么不同   当时答得不太好。后面上网查了资料，发现这篇文章讲得比较详细http://sentsin.com/web/779.html.简言之，从模型到ui的更新，通过$digest循环遍历该作用域注册的">
<meta property="og:type" content="article">
<meta property="og:title" content="2016阿里实习生第一次电话面试总结">
<meta property="og:url" content="http://sj719045032.github.io/2016/03/08/ali-interview/index.html">
<meta property="og:site_name" content="Stone's blog!">
<meta property="og:description" content="2016年3月7日，晚上接到了人生中第一次电话面试-阿里实习生招聘电话面试。打来电话的是一个姐姐，下面是一些问题。
1.angular数据双向绑定的原理，以及与检测对象改变的实现双向绑定有什么不同   当时答得不太好。后面上网查了资料，发现这篇文章讲得比较详细http://sentsin.com/web/779.html.简言之，从模型到ui的更新，通过$digest循环遍历该作用域注册的">
<meta property="og:updated_time" content="2016-03-09T11:42:38.443Z">
<meta name="twitter:card" content="summary">
<meta name="twitter:title" content="2016阿里实习生第一次电话面试总结">
<meta name="twitter:description" content="2016年3月7日，晚上接到了人生中第一次电话面试-阿里实习生招聘电话面试。打来电话的是一个姐姐，下面是一些问题。
1.angular数据双向绑定的原理，以及与检测对象改变的实现双向绑定有什么不同   当时答得不太好。后面上网查了资料，发现这篇文章讲得比较详细http://sentsin.com/web/779.html.简言之，从模型到ui的更新，通过$digest循环遍历该作用域注册的">
  
    <link rel="alternate" href="/atom.xml" title="Stone&#39;s blog!" type="application/atom+xml">
  
  
    <link rel="icon" href="/favicon.png">
  
  
    <link href="//fonts.googleapis.com/css?family=Source+Code+Pro" rel="stylesheet" type="text/css">
  
  <link rel="stylesheet" href="/css/style.css">
  

</head>

<body>
  <div id="container">
    <div id="wrap">
      <header id="header">
  <div id="banner"></div>
  <div id="header-outer" class="outer">
    <div id="header-title" class="inner">
      <h1 id="logo-wrap">
        <a href="/" id="logo"></a>
      </h1>
      
    </div>
    <div id="header-inner" class="inner">
      <nav id="main-nav">
        <a id="main-nav-toggle" class="nav-icon"></a>
        
          <a class="main-nav-link" href="/">Home</a>
        
          <a class="main-nav-link" href="/archives">Archive</a>
        
      </nav>
      <nav id="sub-nav">
        
          <a id="nav-rss-link" class="nav-icon" href="/atom.xml" title="RSS Feed"></a>
        
        <a id="nav-search-btn" class="nav-icon" title="搜索"></a>
      </nav>
      <div id="search-form-wrap">
        <form action="//google.com/search" method="get" accept-charset="UTF-8" class="search-form"><input type="search" name="q" results="0" class="search-form-input" placeholder="Search"><button type="submit" class="search-form-submit">&#xF002;</button><input type="hidden" name="sitesearch" value="http://sj719045032.github.io"></form>
      </div>
    </div>
  </div>
</header>
      <div class="outer">
        <section id="main"><article id="post-ali-interview" class="article article-type-post" itemscope itemprop="blogPost">
  <div class="article-meta">
    <a href="/2016/03/08/ali-interview/" class="article-date">
  <time datetime="2016-03-08T03:58:08.000Z" itemprop="datePublished">2016-03-08</time>
</a>
    
  </div>
  <div class="article-inner">
    
    
      <header class="article-header">
        
  
    <h1 class="article-title" itemprop="name">
      2016阿里实习生第一次电话面试总结
    </h1>
  

      </header>
    
    <div class="article-entry" itemprop="articleBody">
      
        <p>　　　　2016年3月7日，晚上接到了人生中第一次电话面试-阿里实习生招聘电话面试。打来电话的是一个姐姐，下面是一些问题。</p>
<h3 id="1-angular数据双向绑定的原理，以及与检测对象改变的实现双向绑定有什么不同"><a href="#1-angular数据双向绑定的原理，以及与检测对象改变的实现双向绑定有什么不同" class="headerlink" title="1.angular数据双向绑定的原理，以及与检测对象改变的实现双向绑定有什么不同"></a>1.angular数据双向绑定的原理，以及与检测对象改变的实现双向绑定有什么不同</h3><p>   当时答得不太好。后面上网查了资料，发现这篇文章讲得比较详细<a href="http://sentsin.com/web/779.html" target="_blank" rel="external">http://sentsin.com/web/779.html</a>.简言之，从模型到ui的更新，通过$digest循环遍历该作用域注册的所有watch，对比模型值是否改变，如果出现新值就把变化更新到视图上。从UI更新到模型，核心是$apply函数，如果是使用angular扩展的事件，那么angular就是自动调用$apply函数然后启动watch检测，将数据变化更新到模型。</p>
<h3 id="2-angular依赖注入"><a href="#2-angular依赖注入" class="headerlink" title="2.angular依赖注入"></a>2.angular依赖注入</h3><p>   在angular有下面三种方式:</p>
<ul>
<li><p>通过数组标注在方法的参数中声明依赖（优先考虑）</p>
</li>
<li><p>定义在控制器构造方法的$inject属性中</p>
</li>
<li><p>通过方法参数名隐式的添加(有些注意事项)</p>
</li>
</ul>
<ol>
<li><p>数组标注</p>
<pre><code>myModule.controller(&apos;myController&apos;,[&apos;$scope&apos;,&apos;myService&apos;,function($scope,myService){
//your code.            
}]);
</code></pre><p>在第二个数组类型的参数中声明了两个依赖$scope,myService.后面的function中的参数$scope,myService与前面生命的依赖一一对应，可以改成符合js命名规范的任意标示符，比如：</p>
<pre><code>myModule.controller(&apos;myController&apos;,[&apos;$scope&apos;,&apos;myService&apos;,function(myScope,aService){
//your code.            
}]);
</code></pre><p>这样myScope便对应$scope服务，aService对应myService。</p>
</li>
</ol>
<ol>
<li><p>$inject属性</p>
<pre><code>var myController=function($scope,myService){
//your code.            
}];
 myController.$inject=[&apos;$scope&apos;,&apos;myService&apos;];
 myModule.controller(&apos;myController&apos;,myController);
</code></pre></li>
<li><p>隐式声明依赖</p>
<pre><code>myModule.controller(&apos;myController&apos;,function($scope,myService){
       //your code.            
       });
</code></pre><p>将构造函数的参数设为需要依赖的服务名，这样注入器就会自动查找需要依赖的服务</p>
</li>
</ol>
<h3 id="3-闭包及其优缺点"><a href="#3-闭包及其优缺点" class="headerlink" title="3.闭包及其优缺点"></a>3.闭包及其优缺点</h3><p>   闭包定义：javascript允许使用内部函数，内部函数可以访问它们所在的外部函数中声明的所有局部变量、参数和声明的其他内部函数。当其中一个这样的内部函数在包含它们的外部函数之外被调用时，就会形成闭包。</p>
<ul>
<li>优点：<ul>
<li>不增加额外的全局变量。</li>
<li>执行过程中所有变量都是在匿名函数内部。</li>
<li>加强封装性</li>
</ul>
</li>
<li>缺点<ul>
<li>由于闭包会使得函数中的变量都被保存在内存中，内存消耗很大，所以不能滥用闭包，否则会造成网页的性能问题，在IE中可能导致内存泄露。解决方法是，在退出函数之前，将不使用的局部变量全部删除。</li>
<li>闭包会在父函数外部，改变父函数内部变量的值。所以，如果你把父函数当作对象（object）使用，把闭包当作它的公用方法（Public Method），把内部变量当作它的私有属性（private value），这时一定要小心，不要随便改变父函数内部变量的值。</li>
</ul>
</li>
</ul>
<h3 id="4-ajax优缺点"><a href="#4-ajax优缺点" class="headerlink" title="4.ajax优缺点"></a>4.ajax优缺点</h3><p>   ajax：AJAX全称为“Asynchronous JavaScript and XML”（异步JavaScript和XML），是一种创建交互式网页应用的网页开发技术。它使用：</p>
<ul>
<li>使用XHTML+CSS来标准化呈现；</li>
<li>使用XML和XSLT进行数据交换及相关操作；</li>
<li>使用XMLHttpRequest对象与Web服务器进行异步数据通信； </li>
<li>使用Javascript操作Document Object Model进行动态显示及交互； </li>
<li><p>使用JavaScript绑定和处理所有数据。</p>
<ul>
<li>优点：<ul>
<li>无刷新更新数据</li>
<li>异步与服务器通信</li>
<li>前端和后端负载平衡</li>
<li>基于标准被广泛支持</li>
<li>界面与应用分离</li>
</ul>
</li>
<li>缺点<ul>
<li>无法使用Back和History功能</li>
<li>安全问题 AJAX暴露了与服务器交互的细节</li>
<li>对搜索引擎的支持比较弱</li>
<li>破坏了程序的异常机制</li>
<li>违背URL和资源定位的初衷</li>
<li>客户端过肥，太多客户端代码造成开发上的成本</li>
</ul>
</li>
</ul>
</li>
</ul>
<h3 id="5-javascript中的this理解"><a href="#5-javascript中的this理解" class="headerlink" title="5.javascript中的this理解"></a>5.javascript中的this理解</h3><p>   this是Javascript语言的一个关键字它代表函数运行时，自动生成的一个内部对象，只能在函数内部使用，随着函数使用场合的不同，this的值会发生变化。但是有一个总的原则，那就是this指的是，调用函数的那个对象。</p>
<ol>
<li><p>作为对象方法调用<br> 如果函数作为某个对象的方法调用，那么this绑定到这个对象上。</p>
<pre><code>function myFunc() {
   console.log(this.x);
}
var myObject = {};
myObject.x = &quot;stone&quot;;
myObject.myFunc = myFunc;
myObject.myFunc();//输入为‘stone’
</code></pre></li>
<li><p>作为函数调用<br>  如果函数直接作为函数调用，那么this绑定到全局对象，浏览器中也就是window。</p>
<pre><code>var x = &apos;stone&apos;;
function myFunc() {
         this.x = &quot;water&quot;;
         console.log(this.x);
}
myFunc();//输出为‘water’
</code></pre></li>
<li><p>作为构造函数调用<br>  作为构造函数，this指向生成的对象。</p>
<pre><code>function Stone() {
         this.name = &quot;stone&quot;;
}
myStone = new Stone();
console.log(myStone.name);//输入‘stone’
</code></pre></li>
<li><p>通过apply/call调用<br>  apply/call可以改变函数的调用对象，他们的第一个参数代表改变后调用这个函数的对象</p>
<pre><code>name = &apos;Global&apos;;
var Stone = {
    name: &apos;Stone&apos;
};
function showName() {
    console.log(this.name);
}
showName.apply();//输入为‘Global’,未改变this指向
showName.apply(Stone);//输出为‘Stone’，this指向为Stone对象
</code></pre></li>
<li><p>自执行函数<br>  自行函数this指向全局对象，浏览器中是window</p>
<pre><code>name=&apos;Global&apos;;
var Stone={
   name:&apos;stone&apos;,
   showName:function(){
       console.log(this.name);
       (function(){
           console.log(this.name);
       })();
   }
};
Stone.showName();//输出stone Global
</code></pre></li>
</ol>
<h3 id="6-js事件代理（委托）"><a href="#6-js事件代理（委托）" class="headerlink" title="6.js事件代理（委托）"></a>6.js事件代理（委托）</h3><p>  事件阶段：事件捕获-&gt;目标-&gt;事件冒泡</p>
<ol>
<li><p>事件捕获阶段</p>
<p> 事件的第一个阶段是捕获阶段。事件从文档的根节点出发，随着DOM树的结构向事件的目标节点流去。途中经过各个层次的DOM节点，并在各节点上触发捕获事件，直到到达时间的目标节点。捕获阶段的主要任务是遍历传播路径，在冒泡阶段，时间会通过这个路径回溯到文档根节点。在实际应用中，我们并没有太多使用捕获阶段监听的用例，但是通过在捕获阶段对事件的处理，我们可以阻止类似click事件在某个特定元素上被触发。</p>
</li>
<li><p>目标阶段</p>
<p> 当事件到达目标节点时，事件就进入了目标阶段。事件在目标节点上被触发，然后逆向回流，知道传播到最外层的文档节点。</p>
</li>
<li><p>冒泡阶段</p>
<p> 事件在目标事件上触发后，并不在这个元素上终止。它会随着DOM树一层层向上冒泡，直到到达最外层的根节点。也就是说，同一事件会一次在目标节点的父节点，父节点的父节点…直到最外层的节点上触发。 </p>
<p>事件代理：把事件处理器添加到一个父级元素上。默认情况下，由于事件在目标元素上面触发后，还会一次冒泡到DOM树最上层，所以事件代理得以实现。这样我们可以在上层元素通过判断事件的目标，来对目标元素采取相应的操作。</p>
</li>
</ol>
<h3 id="7-position几种属性"><a href="#7-position几种属性" class="headerlink" title="7.position几种属性"></a>7.position几种属性</h3><table>
<thead>
<tr>
<th>值</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>absolute</td>
<td>生成绝对定位的元素，相对于 static 定位以外的第一个父元素进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td>
</tr>
<tr>
<td>fixed</td>
<td>生成绝对定位的元素，相对于浏览器窗口进行定位。元素的位置通过 “left”, “top”, “right” 以及 “bottom” 属性进行规定。</td>
</tr>
<tr>
<td>relative</td>
<td>生成相对定位的元素，相对于其正常位置进行定位。因此，”left:20” 会向元素的 LEFT 位置添加 20 像素。</td>
</tr>
<tr>
<td>static</td>
<td>默认值。没有定位，元素出现在正常的流中（忽略 top, bottom, left, right 或者 z-index 声明）。</td>
</tr>
<tr>
<td>inherit</td>
<td>规定应该从父元素继承 position 属性的值。</td>
</tr>
</tbody>
</table>
<h3 id="8-display属性"><a href="#8-display属性" class="headerlink" title="8.display属性"></a>8.display属性</h3><ul>
<li><p>inline(行内元素)</p>
<ul>
<li>和其他元素都在一行上</li>
<li>元素的高度、宽度、行高及顶部和底部边距不可设置</li>
<li>元素的宽度就是它包含的文字或图片的宽度，不可改变</li>
</ul>
</li>
<li><p>block(块元素)</p>
<ul>
<li>每个块级元素都从新的一行开始，并且其后的元素也另起一行</li>
<li>元素的高度、宽度、行高以及顶和底边距都可设置</li>
<li>元素宽度在不设置的情况下，是它本身父容器的100%（和父元素的宽度一致），除非设定一个宽度</li>
</ul>
</li>
<li><p>inline-block</p>
<p>inline-block既具有block的宽高特性又具有inline的同行元素特性。</p>
</li>
</ul>
<h3 id="9-BFC-Block-formatting-context-块级格式化上下文"><a href="#9-BFC-Block-formatting-context-块级格式化上下文" class="headerlink" title="9.BFC(Block formatting context)块级格式化上下文"></a>9.BFC(Block formatting context)块级格式化上下文</h3><p>   它是一个独立的渲染区域，只有Block-level box参与， 它规定了内部的Block-level Box如何布局，并且与这个区域外部毫不相干。</p>
<ul>
<li><p>BFC布局规则：</p>
<ul>
<li>内部的Box会在垂直方向，一个接一个地放置。</li>
<li>Box垂直方向的距离由margin决定。属于同一个BFC的两个相邻Box的margin会发生重叠</li>
<li>每个元素的margin box的左边， 与包含块border box的左边相接触(对于从左往右的格式化，否则相反)。即使存在浮动也是如此。</li>
<li>BFC的区域不会与float box重叠。</li>
<li>BFC就是页面上的一个隔离的独立容器，容器里面的子元素不会影响到外面的元素。反之也如此。</li>
<li>计算BFC的高度时，浮动元素也参与计算</li>
</ul>
</li>
<li><p>产生BFC的元素</p>
<ul>
<li>根元素</li>
<li>float属性不为none</li>
<li>position为absolute或fixed</li>
<li>display为inline-block, table-cell, table-caption, flex, inline-flex</li>
<li>overflow不为visible</li>
</ul>
</li>
</ul>
<h3 id="10-OSI七层模型"><a href="#10-OSI七层模型" class="headerlink" title="10.OSI七层模型"></a>10.OSI七层模型</h3><table>
<thead>
<tr>
<th>OSI层</th>
<th>功能</th>
<th>协议</th>
</tr>
</thead>
<tbody>
<tr>
<td>应用层</td>
<td>文件传输，电子邮件，文件服务，虚拟终端</td>
<td>TFTP，HTTP，SNMP，FTP，SMTP，DNS，Telnet</td>
</tr>
<tr>
<td>表示层</td>
<td>数据格式化，代码转换，数据加密</td>
<td>没有协议</td>
</tr>
<tr>
<td>会话层</td>
<td>解除或建立与别的接点的联系</td>
<td>没有协议</td>
</tr>
<tr>
<td>传输层</td>
<td>提供端对端的接口</td>
<td>TCP，UDP</td>
</tr>
<tr>
<td>网络层</td>
<td>为数据包选择路由</td>
<td>IP，ICMP，RIP，OSPF，BGP，IGMP</td>
</tr>
<tr>
<td>数据链路层</td>
<td>传输有地址的帧以及错误检测功能</td>
<td>SLIP，CSLIP，PPP，ARP，RARP，MTU</td>
</tr>
<tr>
<td>物理层</td>
<td>以二进制数据形式在物理媒体上传输数据</td>
<td>ISO2110，IEEE802，IEEE802.2</td>
</tr>
</tbody>
</table>
<h3 id="11-http"><a href="#11-http" class="headerlink" title="11 http"></a>11 http</h3><p>   HTTP是Hyper Text Transfer Protocol（超文本传输协议）的缩写</p>
<ol>
<li><p>工作流程</p>
<ul>
<li>首先客户机与服务器需要建立连接。只要单击某个超级链接，HTTP的工作开始</li>
<li>建立连接后，客户机发送一个请求给服务器，请求方式的格式为：统一资源标识符（URL）、协议版本号，后边是MIME信息包括请求修饰符、客户机信息和可能的内容。</li>
<li>服务器接到请求后，给予相应的响应信息，其格式为一个状态行，包括信息的协议版本号、一个成功或错误的代码，后边是MIME信息包括服务器信息、实体信息和可能的内容。</li>
<li>客户端接收服务器所返回的信息通过浏览器显示在用户的显示屏上，然后客户机与服务器断开连接。</li>
</ul>
</li>
<li><p>常用状态吗</p>
</li>
</ol>
<table>
<thead>
<tr>
<th>消息</th>
<th>描述</th>
</tr>
</thead>
<tbody>
<tr>
<td>200（成功）</td>
<td>服务器已成功处理了请求。通常，这表示服务器提供了请求的网页。</td>
</tr>
<tr>
<td>301（永久移动）</td>
<td>请求的网页已永久移动到新位置。服务器返回此响应（对 GET 或 HEAD 请求的响应）时，会自动将请求者转到新位置。您应使用此代码告诉 Googlebot 某个网页或网站已永久移动到新位置。</td>
</tr>
<tr>
<td>302（临时移动）</td>
<td>服务器目前从不同位置的网页响应请求，但请求者应继续使用原有位置来响应以后的请求。此代码与响应 GET 和 HEAD 请求的 301 代码类似，会自动将请求者转到不同的位置，但您不应使用此代码来告诉 Googlebot 某个网页或网站已经移动，因为 Googlebot 会继续抓取原有位置并编制索引。</td>
</tr>
<tr>
<td>304（未修改）</td>
<td>自从上次请求后，请求的网页未修改过。服务器返回此响应时，不会返回网页内容。如果网页自请求者上次请求后再也没有更改过，您应将服务器配置为返回此响应（称为 If-Modified-Since HTTP 标头）。服务器可以告诉 Googlebot 自从上次抓取后网页没有变更，进而节省带宽和开销。</td>
</tr>
<tr>
<td>404（未找到）</td>
<td>服务器找不到请求的网页。例如，对于服务器上不存在的网页经常会返回此代码。</td>
</tr>
<tr>
<td>503（服务不可用）</td>
<td>服务器目前无法使用（由于超载或停机维护）。通常，这只是暂时状态。</td>
</tr>
</tbody>
</table>

      
    </div>
    <footer class="article-footer">
      <a data-url="http://sj719045032.github.io/2016/03/08/ali-interview/" data-id="cilkq6hrw0000fsumtvut9tdz" class="article-share-link">Share</a>
      
      
  <ul class="article-tag-list"><li class="article-tag-list-item"><a class="article-tag-list-link" href="/tags/面试/">面试</a></li></ul>

    </footer>
  </div>
  
    
<nav id="article-nav">
  
  
    <a href="/2016/03/03/simple_grammar/" id="article-nav-older" class="article-nav-link-wrap">
      <strong class="article-nav-caption">Older</strong>
      <div class="article-nav-title">markdown基本语法</div>
    </a>
  
</nav>

  
</article>

</section>
        
          <aside id="sidebar">
  
    

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签</h3>
    <div class="widget">
      <ul class="tag-list"><li class="tag-list-item"><a class="tag-list-link" href="/tags/javascrippt/">javascrippt</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/markdown/">markdown</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/闭包-javascript/">闭包 javascript</a></li><li class="tag-list-item"><a class="tag-list-link" href="/tags/面试/">面试</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">标签云</h3>
    <div class="widget tagcloud">
      <a href="/tags/javascrippt/" style="font-size: 10px;">javascrippt</a> <a href="/tags/markdown/" style="font-size: 10px;">markdown</a> <a href="/tags/闭包-javascript/" style="font-size: 10px;">闭包 javascript</a> <a href="/tags/面试/" style="font-size: 10px;">面试</a>
    </div>
  </div>

  
    
  <div class="widget-wrap">
    <h3 class="widget-title">归档</h3>
    <div class="widget">
      <ul class="archive-list"><li class="archive-list-item"><a class="archive-list-link" href="/archives/2016/03/">三月 2016</a></li></ul>
    </div>
  </div>


  
    
  <div class="widget-wrap">
    <h3 class="widget-title">最新文章</h3>
    <div class="widget">
      <ul>
        
          <li>
            <a href="/2016/03/08/ali-interview/">2016阿里实习生第一次电话面试总结</a>
          </li>
        
          <li>
            <a href="/2016/03/03/simple_grammar/">markdown基本语法</a>
          </li>
        
          <li>
            <a href="/2016/03/03/bibao/">js闭包之我见</a>
          </li>
        
          <li>
            <a href="/2016/03/03/javacript_add/">javacript不能精确相加之0.1+0.2！=0.3</a>
          </li>
        
      </ul>
    </div>
  </div>

  
</aside>
        
      </div>
      <footer id="footer">
  
  <div class="outer">
    <div id="footer-info" class="inner">
      &copy; 2016 Stone<br>
      Powered by <a href="http://hexo.io/" target="_blank">Hexo</a>
    </div>
  </div>
</footer>
    </div>
    <nav id="mobile-nav">
  
    <a href="/" class="mobile-nav-link">Home</a>
  
    <a href="/archives" class="mobile-nav-link">Archive</a>
  
</nav>
    

<script src="http://libs.baidu.com/jquery/2.0.0/jquery.min.js"></script>


  <link rel="stylesheet" href="/fancybox/jquery.fancybox.css">
  <script src="/fancybox/jquery.fancybox.pack.js"></script>


<script src="/js/script.js"></script>

  </div>
</body>
</html>